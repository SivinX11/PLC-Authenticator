import cv2
import os
import sys
import numpy
import matplotlib.pyplot as plt
from enhance import image_enhance
from skimage.morphology import skeletonize, thin
import streamlit as st
import webbrowser
import time

#os.chdir("/app/")

def removedot(invertThin):
    temp0 = numpy.array(invertThin[:])
    temp0 = numpy.array(temp0)
    temp1 = temp0/255
    temp2 = numpy.array(temp1)
    temp3 = numpy.array(temp2)

    enhanced_img = numpy.array(temp0)
    filter0 = numpy.zeros((10,10))
    W,H = temp0.shape[:2]
    filtersize = 6

    for i in range(W - filtersize):
        for j in range(H - filtersize):
            filter0 = temp1[i:i + filtersize,j:j + filtersize]

            flag = 0
            if sum(filter0[:,0]) == 0:
                flag +=1
            if sum(filter0[:,filtersize - 1]) == 0:
                flag +=1
            if sum(filter0[0,:]) == 0:
                flag +=1
            if sum(filter0[filtersize - 1,:]) == 0:
                flag +=1
            if flag > 3:
                temp2[i:i + filtersize, j:j + filtersize] = numpy.zeros((filtersize, filtersize))

    return temp2


def get_descriptors(img):
	clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
	img = clahe.apply(img)
	img = image_enhance.image_enhance(img)
	img = numpy.array(img, dtype=numpy.uint8)
	# Threshold
	ret, img = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)
	# Normalize to 0 and 1 range
	img[img == 255] = 1

	#Thinning
	skeleton = skeletonize(img)
	skeleton = numpy.array(skeleton, dtype=numpy.uint8)
	skeleton = removedot(skeleton)
	# Harris corners
	harris_corners = cv2.cornerHarris(img, 3, 3, 0.04)
	harris_normalized = cv2.normalize(harris_corners, 0, 255, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32FC1)
	threshold_harris = 125
	# Extract keypoints
	keypoints = []
	for x in range(0, harris_normalized.shape[0]):
		for y in range(0, harris_normalized.shape[1]):
			if harris_normalized[x][y] > threshold_harris:
				keypoints.append(cv2.KeyPoint(y, x, 1))
	# Define descriptor
	orb = cv2.ORB_create()
	# Compute descriptors
	_, des = orb.compute(img, keypoints)
	return (keypoints, des);


def main():

	#Sidebar_Section
	st.set_page_config(page_title='PLC Authenticator', layout='centered', initial_sidebar_state='expanded')
	st.sidebar.markdown("# PLC Authenticator")
	st.sidebar.markdown("#####    ")
	st.sidebar.markdown("#### A system for providing access to a PLC controlled subcomponent of an automation system. The system comprises a biometric identification device coupled to an I/O device of the automation system. The I/O device is configured to process input from the biometric identification device and provide an identification code for a user of the biometric identification device. The system further comprises a PLC based server configured to receive the identification code generated by the I/O device and process the identification code to determine whether to provide access to a PLC controlled subcomponent of the automation system to the user.")
	st.sidebar.markdown("# ")
	st.sidebar.markdown("# ")
	st.sidebar.markdown("# ")
	st.sidebar.markdown("## Developers:")
	st.sidebar.markdown("* Prateek Yashaswi")
	st.sidebar.markdown("* Rishav Chowdhury")
	st.sidebar.markdown("* Sivin Varughese")
	link1 = '[Presentation](https://rishav-chowdhury.github.io/)'
	link2 = '[Video](https://github.com/Rishav-Chowdhury)'
	st.sidebar.markdown("# ")
	st.sidebar.markdown(link1, unsafe_allow_html=True)
	st.sidebar.markdown(link2, unsafe_allow_html=True)

	#Introducion
	st.title("Authentication System for PLC")
	st.markdown("# ")
	st.markdown("## Introduction")
	st.markdown("### The following system is acts as a biometric safeguard system for Industrial Automation Systems like SCADA. Programmable Logic Controllers (PLC) are complex devices and need restricted access. This system authorizes users based on fingerprint verification with 95 percent ccuracy.")
	st.markdown("### The system enhances fingerprints by graysacling, skeletonizing and using the Harris Corner Detection Algorithm for edge detection.")
	st.markdown("# ")

	#Instruction
	st.markdown("# ")
	st.markdown("## Instructions")
	with st.beta_expander("Display Instructions"):
		st.markdown("* Enter your fingerprint through the sensor and let the system generate an image.")
		st.markdown("* Upload the system generated image (User Template) as the first image.")
		st.markdown("* Ask the supervisor to provide your Authentication Template as the second image.")
		st.markdown("* Wait for the system to process the fingerprints and check the displayed message.")
		st.markdown("* If authenticated, proceed to the PLC section and click on the button to access system.")
	
	#Image 1
	st.markdown("# ")
	st.markdown("## User Template")
	with st.beta_expander("Upload User Template"):
		image_file = st.file_uploader("Upload User Image in .TIF Format")
		if image_file is not None:
			file_details = {"FileName":image_file.name,"FileType":image_file.type}
			st.write(file_details)
			with open(os.path.join("tempDir",image_file.name),"wb") as f: 
				f.write(image_file.getbuffer())
			st.success("Saved File")
			image_name = image_file.name
			img1 = cv2.imread("tempDir/" + image_name, cv2.IMREAD_GRAYSCALE)
			kp1, des1 = get_descriptors(img1)

			#Image 2
			st.markdown("# ")
			st.markdown("## Authentication Template")
			image_file1 = st.file_uploader("Upload Authentication Image in .TIF Format")
			if image_file1 is not None:
				file_details = {"FileName":image_file1.name,"FileType":image_file1.type}
				st.write(file_details)
				with open(os.path.join("tempDir",image_file1.name),"wb") as f: 
					f.write(image_file1.getbuffer())
				st.success("Saved File")
				image_name = image_file1.name
				img2 = cv2.imread("tempDir/" + image_name, cv2.IMREAD_GRAYSCALE)
				kp2, des2 = get_descriptors(img2)

				# Matching between descriptors
				bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
				matches = sorted(bf.match(des1, des2), key= lambda match:match.distance)
				# Plot keypoints
				img4 = cv2.drawKeypoints(img1, kp1, outImage=None)
				img5 = cv2.drawKeypoints(img2, kp2, outImage=None)
				f, axarr = plt.subplots(1,2)
				axarr[0].imshow(img4)
				axarr[1].imshow(img5)
				plt.show()
				# Plot matches
				img3 = cv2.drawMatches(img1, kp1, img2, kp2, matches, flags=2, outImg=None)
				plt.imshow(img3)
				plt.show()

				# Calculate score
				score = 0;
				for match in matches:
					score += match.distance
				score_threshold = 33

				st.markdown("# ")
				st.markdown("## Confirmation Message")
				st.spinner()
				with st.spinner(text='In progress'):
					time.sleep(1)
					if score/len(matches) < score_threshold:
						#print("Fingerprint matches.")
						st.success('AUTHENTICATED')
						st.markdown("# ")
						st.markdown("## Access PLC")
						url = "https://app.plcsimulator.online/"
						if st.button('Access PLC', key='Give Access', help='Enter the Simulator'):
							webbrowser.open_new_tab(url)
					else:
						#print("Fingerprint does not match.")
						st.error('UNAUTHORISED USER')




if __name__ == "__main__":
	try:
		main()
	except:
		raise
